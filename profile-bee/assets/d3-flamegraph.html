<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>{title}</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, monospace; background: #fafafa; }
.toolbar {
  display: flex; align-items: center; gap: 8px; padding: 8px 12px;
  background: #fff; border-bottom: 1px solid #ddd; flex-wrap: wrap;
}
.toolbar a, .toolbar button {
  padding: 4px 10px; border: 1px solid #ccc; border-radius: 3px;
  background: #f5f5f5; color: #333; text-decoration: none; cursor: pointer;
  font-size: 13px; line-height: 1.4;
}
.toolbar a:hover, .toolbar button:hover { background: #e8e8e8; }
.toolbar input[type="text"] {
  padding: 4px 8px; border: 1px solid #ccc; border-radius: 3px; font-size: 13px;
}
.toolbar .title { font-weight: 600; margin-right: auto; }
.toolbar .title a { border: none; background: none; font-size: 14px; color: #333; }
.toolbar .title a:hover { text-decoration: underline; background: none; }
#status { font-size: 12px; color: #888; }
#details {
  padding: 6px 12px; font-size: 13px; color: #555;
  background: #fff; border-top: 1px solid #ddd; min-height: 24px;
}
canvas { display: block; width: 100%; cursor: pointer; }
</style>
</head>
<body>
<div class="toolbar">
  <span class="title"><a href="https://github.com/zz85/profile-bee" target="_blank" rel="noopener">{title}</a></span>
  <button onclick="startStream()">Realtime updates</button>
  <span id="status"></span>
  <button onclick="fetchAndUpdate()">Update</button>
  <button onclick="resetZoom()">Reset zoom</button>
  <input type="text" id="search" placeholder="Search..." oninput="onSearch(this.value)">
  <button onclick="clearSearch()">Clear</button>
</div>
<canvas id="fg"></canvas>
<div id="details">&nbsp;</div>

<script>
// ── Data ─────────────────────────────────────────────────────────
var rawData = {stack};

// ── Flamegraph state ─────────────────────────────────────────────
var frames = [];       // flat array: {name, depth, x, w, value, selfValue, children, parent, color}
var rootFrame = null;
var zoomFrame = null;  // currently zoomed frame (null = root)
var searchTerm = "";
var hoveredFrame = null;
var totalLevels = 0;

var CELL_H = 20;
var FONT = '12px monospace';
var canvas = document.getElementById('fg');
var ctx = canvas.getContext('2d');
var dpr = window.devicePixelRatio || 1;
var canvasW = 0;
var canvasH = 0;

// ── Color palette ────────────────────────────────────────────────
function hashColor(name) {
  var h = 0;
  for (var i = 0; i < name.length; i++) h = ((h << 5) - h + name.charCodeAt(i)) | 0;
  // warm flame palette: hue 20-55 (orange-yellow), sat 60-90%, light 55-75%
  var hue = 20 + Math.abs(h % 36);
  var sat = 60 + Math.abs((h >> 8) % 31);
  var lit = 55 + Math.abs((h >> 16) % 21);
  return 'hsl(' + hue + ',' + sat + '%,' + lit + '%)';
}

function dimColor(name) {
  var h = 0;
  for (var i = 0; i < name.length; i++) h = ((h << 5) - h + name.charCodeAt(i)) | 0;
  var hue = 20 + Math.abs(h % 36);
  return 'hsl(' + hue + ',20%,80%)';
}

// ── Build flat frame list from {name, value, children} tree ──────
function buildFrames(data) {
  frames = [];
  totalLevels = 0;
  if (!data || !data.value) { rootFrame = null; return; }

  function walk(node, depth, x, parentIdx) {
    var idx = frames.length;
    var w = node.value;
    var selfVal = node.value;
    if (node.children) {
      for (var i = 0; i < node.children.length; i++) selfVal -= node.children[i].value;
    }
    frames.push({
      name: node.name || 'all',
      depth: depth,
      x: x,
      w: w,
      selfValue: Math.max(0, selfVal),
      value: node.value,
      parent: parentIdx,
      color: hashColor(node.name || 'all'),
      dimColor: dimColor(node.name || 'all'),
    });
    if (depth + 1 > totalLevels) totalLevels = depth + 1;
    if (node.children) {
      // sort children by value descending for stable layout
      var sorted = node.children.slice().sort(function(a, b) { return b.value - a.value; });
      var cx = x;
      for (var i = 0; i < sorted.length; i++) {
        walk(sorted[i], depth + 1, cx, idx);
        cx += sorted[i].value;
      }
    }
  }
  walk(data, 0, 0, -1);
  rootFrame = frames[0] || null;
}

// ── Layout & render ──────────────────────────────────────────────
function resize() {
  canvasW = canvas.parentElement.clientWidth;
  canvasH = (totalLevels + 1) * CELL_H;
  canvas.width = canvasW * dpr;
  canvas.height = canvasH * dpr;
  canvas.style.height = canvasH + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function render() {
  if (!rootFrame) {
    canvasW = canvas.parentElement.clientWidth;
    canvasH = 60;
    canvas.width = canvasW * dpr;
    canvas.height = canvasH * dpr;
    canvas.style.height = canvasH + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.clearRect(0, 0, canvasW, canvasH);
    ctx.font = '14px monospace';
    ctx.fillStyle = '#999';
    ctx.textAlign = 'center';
    ctx.fillText('Waiting for profiling data\u2026', canvasW / 2, 30);
    ctx.textAlign = 'start';
    return;
  }
  resize();
  ctx.clearRect(0, 0, canvasW, canvasH);
  ctx.font = FONT;
  ctx.textBaseline = 'middle';

  var base = zoomFrame || rootFrame;
  var baseX = base.x;
  var baseW = base.w;
  if (baseW === 0) return;
  var scale = canvasW / baseW;
  var hasSearch = searchTerm.length > 0;
  var searchLower = searchTerm.toLowerCase();

  for (var i = 0; i < frames.length; i++) {
    var f = frames[i];
    // Compute pixel position relative to zoom
    var px = (f.x - baseX) * scale;
    var pw = f.w * scale;
    // Skip frames outside viewport
    if (px + pw < 0 || px > canvasW) continue;
    if (pw < 0.5) continue;
    // Clamp
    if (px < 0) { pw += px; px = 0; }
    if (px + pw > canvasW) pw = canvasW - px;

    // Y: bottom-up (root at bottom)
    var py = canvasH - (f.depth + 1) * CELL_H;

    // Color
    var isMatch = hasSearch && f.name.toLowerCase().indexOf(searchLower) !== -1;
    var isHovered = (f === hoveredFrame);
    if (hasSearch && !isMatch) {
      ctx.fillStyle = f.dimColor;
    } else if (isHovered) {
      ctx.fillStyle = '#ff8';
    } else {
      ctx.fillStyle = f.color;
    }

    ctx.fillRect(px, py, pw - 0.5, CELL_H - 1);

    // Border for hovered
    if (isHovered) {
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1;
      ctx.strokeRect(px + 0.5, py + 0.5, pw - 1.5, CELL_H - 2);
    }

    // Label
    if (pw > 30) {
      ctx.fillStyle = '#222';
      var maxTextW = pw - 6;
      var label = f.name;
      var measured = ctx.measureText(label).width;
      if (measured > maxTextW) {
        // Truncate with ellipsis
        var ratio = maxTextW / measured;
        var chars = Math.max(1, Math.floor(label.length * ratio) - 2);
        label = label.substring(0, chars) + '..';
      }
      ctx.fillText(label, px + 3, py + CELL_H / 2);
    }
  }
}

// ── Hit testing ──────────────────────────────────────────────────
function frameAt(mx, my) {
  if (!rootFrame) return null;
  var base = zoomFrame || rootFrame;
  var scale = canvasW / base.w;
  // Which depth level?
  var depth = Math.floor((canvasH - my) / CELL_H);
  // Linear scan at that depth (could optimize with spatial index)
  for (var i = 0; i < frames.length; i++) {
    var f = frames[i];
    if (f.depth !== depth) continue;
    var px = (f.x - base.x) * scale;
    var pw = f.w * scale;
    if (mx >= px && mx < px + pw) return f;
  }
  return null;
}

// ── Interaction ──────────────────────────────────────────────────
canvas.addEventListener('mousemove', function(e) {
  var rect = canvas.getBoundingClientRect();
  var f = frameAt(e.clientX - rect.left, e.clientY - rect.top);
  if (f !== hoveredFrame) {
    hoveredFrame = f;
    render();
  }
  var det = document.getElementById('details');
  if (f) {
    var pct = rootFrame.value > 0 ? (f.value / rootFrame.value * 100).toFixed(2) : '0';
    det.textContent = f.name + '  (' + f.value + ' samples, ' + pct + '%, self: ' + f.selfValue + ')';
  } else {
    det.innerHTML = '&nbsp;';
  }
});

canvas.addEventListener('mouseleave', function() {
  hoveredFrame = null;
  render();
  document.getElementById('details').innerHTML = '&nbsp;';
});

canvas.addEventListener('click', function(e) {
  var rect = canvas.getBoundingClientRect();
  var f = frameAt(e.clientX - rect.left, e.clientY - rect.top);
  if (f) {
    zoomFrame = (f === zoomFrame) ? rootFrame : f;
    render();
  }
});

window.addEventListener('resize', render);

// ── Controls ─────────────────────────────────────────────────────
function resetZoom() {
  zoomFrame = null;
  render();
}

function onSearch(term) {
  searchTerm = term;
  render();
}

function clearSearch() {
  document.getElementById('search').value = '';
  searchTerm = '';
  render();
}

// ── Data update (preserves zoom by name path) ────────────────────
function getZoomPath() {
  if (!zoomFrame || zoomFrame === rootFrame) return null;
  // Walk up parent chain to build name path
  var path = [];
  var f = zoomFrame;
  while (f && f.parent >= 0) {
    path.unshift(f.name);
    f = frames[f.parent];
  }
  return path;
}

function restoreZoom(path) {
  if (!path || path.length === 0 || !rootFrame) { zoomFrame = null; return; }
  // Walk down from root's children matching the path
  var candidates = [];
  for (var i = 0; i < frames.length; i++) {
    if (frames[i].parent === 0) candidates.push(i);
  }
  var current = null;
  for (var p = 0; p < path.length; p++) {
    var found = false;
    for (var c = 0; c < candidates.length; c++) {
      if (frames[candidates[c]].name === path[p]) {
        current = candidates[c];
        // Gather children of this frame for next level
        candidates = [];
        for (var i = 0; i < frames.length; i++) {
          if (frames[i].parent === current) candidates.push(i);
        }
        found = true;
        break;
      }
    }
    if (!found) { zoomFrame = null; return; }
  }
  zoomFrame = current !== null ? frames[current] : null;
}

function applyData(data) {
  var savedPath = getZoomPath();
  buildFrames(data);
  restoreZoom(savedPath);
  render();
}

// ── SSE double-buffered updates ──────────────────────────────────
var pendingData = null;
var rafScheduled = false;

function scheduleApply() {
  if (rafScheduled) return;
  rafScheduled = true;
  requestAnimationFrame(function() {
    rafScheduled = false;
    if (pendingData) {
      applyData(pendingData);
      pendingData = null;
    }
  });
}

function startStream() {
  var sse = new EventSource(location.origin + '/stream');
  sse.onopen = function() {
    document.getElementById('status').textContent = 'Connected';
  };
  sse.onmessage = function(msg) {
    pendingData = JSON.parse(msg.data);
    scheduleApply();
  };
  sse.onerror = function() {
    document.getElementById('status').textContent = 'Disconnected';
  };
}

function fetchAndUpdate() {
  fetch('/json').then(function(r) { return r.json(); }).then(applyData).catch(console.warn);
}

// ── Initial render ───────────────────────────────────────────────
buildFrames(rawData);
render();
// Auto-start SSE for live updates; also fetch in case inline data was empty
startStream();
if (!rootFrame) fetchAndUpdate();
</script>
</body>
</html>
